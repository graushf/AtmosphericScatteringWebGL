<html>
	<head>
		<title>Atmospheric Scattering - Prototype </title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<script type="text/javascript" src="gl-matrix.js"></script>
		<script type="text/javascript" src="webgl-utils.js"></script>
		<script type="text/javascript" src="camera-3d.js"></script>
		<script type="text/javascript" src="event-handler.js"></script>
		<script type="text/javascript" src="geometry-generator.js"></script>
		<script type="text/javascript" src="renderer.js"></script>
		<script type="text/javascript" src="framebuffer-manager.js"></script>
		<script type="text/javascript" src="ray.js"></script>
		<script type="text/javascript" src="game-engine.js"></script>
		<script type="text/javascript" src="shader.js"></script>

		<!-- Shader code -->
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;

			uniform vec3 uColor; 
			uniform float uOpacity;
			
			void main(void) {
				gl_FragColor = vec4(uColor, uOpacity);
			}
		</script>

		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;

			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;

			void main(void) {
				gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
			}
		</script>

		<script id="shader-fs-framebuffer" type="x-shader/x-fragment">
			precision mediump float;

			varying vec2 vTextureCoord;

			uniform sampler2D uSampler;
			
			uniform int uDrawBorder;

			void main(void) {
				if (uDrawBorder == 0) {
					gl_FragColor = texture2D(uSampler, vTextureCoord);
				} else {
					gl_FragColor = vec4(0.46, 0.71, 0.0, 1.0);
				}
				//gl_FragColor = vec4(vTextureCoord, 0.0, 1.0);
			}
		</script>

		<script id="shader-vs-framebuffer" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			varying vec2 vTextureCoord;

			uniform mat4 model;

			void main(void) {
				vTextureCoord = aTextureCoord;
				gl_Position = model * vec4(aVertexPosition, 1.0);
			}
		</script>


		<script id="SpaceFromSpace-fs" type="x-shader/x-fragment">
			precision mediump float;

			uniform sampler2D s2Test;

			varying vec2 vTextureCoord;

			void main(void) 
			{
				gl_FragColor = gl_FrontSecondaryColor * texture2D(s2Test, vTextureCoord);
				//gl_FragColor = gl_SecondaryColor;
			}
		</script>

		<script id="SpaceFromSpace-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;


			varying vec2 vTextureCoord;

			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;

			uniform vec3 v3CameraPos;		// The camera's current position
			uniform vec3 v3LightPos;		// The direciton vector to the light source
			uniform vec3 v3InvWavelength;	// The 1 / pow(wavelength, 4) for the red, green and blue channels
			uniform float fCameraHeight;	// The camera's current height
			uniform float fCameraHeight2;	// fCameraHeight^2
			uniform float fOuterRadius;		// The outer (atmosphere) radius
			uniform float fOuterRadius2;	// fOuterRadius^2
			uniform float fInnerRadius;		// The inner (planetary) radius
			uniform float fInnerRadius2;	// fInnerRadius^2
			uniform floaf fKrESun;			// Kr * ESun
			uniform float fKmESun;			// Km * ESun
			uniform float fKr4PI;			// Kr * 4 * PI
			uniform float fKm4PI;			// Km * 4 * PI
			uniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)
			uniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)
			uniform float fScaleOverScaleDepth;	// fScale / fScaleDepth

			float scale(float fCos)
			{
				float x = 1.0 - fCos;
				return fScaleDepth * exp(-0.00278 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
			}

			void main(void)
			{
				// Get the ray from the camera to the vertex and its length
				vec3 v3Pos = aVertexPosition;
				vec3 vRay = v3Pos - v3CameraPos;
				float fFar = length(v3Ray);
				v3Ray /= fFar;

				// Calculate the farther intersection of the ray with the outer atmosphere (which is the far point of the ray passing through the atmosphere)
				float B = 2.0 * dot(v3CameraPos, v3Ray);
				float C = fCameraHeight2 - fOuterRadius2;
				float fDet = max(0.0, B*B - 4.0 * C);
				fFar = 0.5 * (-B + sqrt(fDet));
				float fNear = 0.5 * (-B - sqrt(fDet));

				vec3 v3Start = v3CameraPos + v3Ray*fNear;
				fFar -= fNear;

				// Calculate attenuation from the camera to the top of the atmosphere toward the vertex
				float fHeight = length(v3Start);
				float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));
				float fAngle = dot(v3Ray, v3Start) / fHeight;
				float fScatter = fDepth*scale(fAngle);
				gl_FrontSecondaryColor.rgb = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));

				gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
				vTextureCoord = aTextureCoord;
			}
		</script>


		<script id="GroundFromSpace-fs" type="x-shader/x-fragment">
			precision mediump float;
			//uniform sampler2D s2Tex1;
			//uniform sampler2D s2Tex2;
			varying vec3 primaryColor;
			varying vec3 secondaryColor;

			void main(void) 
			{
				gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); return;
				gl_FragColor = vec4(vec3(primaryColor + 0.25 * secondaryColor).xyz, 1.0);
				//gl_FragColor = gl_Color + texture2D(s2Tex1, gl_TexCoord[0].st) * texture2D(s2Tex2, gl_TexCoord[1].st) * gl_SecondaryColor;
			}

		</script>


		<script id="GroundFromSpace-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			varying vec2 vTextureCoord;
			varying vec3 primaryColor;
			varying vec3 secondaryColor;

			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;

			uniform vec3 v3CameraPos;			// The camera's current position
			uniform vec3 v3LightPos;			// The direciton vector to the light source
			uniform vec3 v3InvWavelength;		// 1 / pow(wavelength, 4) for the red, green, and blue channels
			uniform float fCameraHeight;		// The camera's current height
			uniform float fCameraHeight2;		// fCameraHeight^2
			uniform float fOuterRadius;			// The outer (atmosphere) radius
			uniform float fOuterRadius2;		// fOuterRadius^2
			uniform float fInnerRadius;			// The inner (planetary) radius
			uniform float fInnerRadius2;		// fInnerRadius^2
			uniform float fKrESun;				// Kr * ESun
			uniform float fKmESun;				// Km * ESun
			uniform float fKr4PI;				// Kr * 4 * PI
			uniform float fKm4PI;				// Km * 4 * PI
			uniform float fScale;				// 1 / (fOuterRadius - fInnerRadius)
			uniform float fScaleDepth;			// The scale depth (i.e. the altitude at which the atmosphere's average density is found)
			uniform float fScaleOverScaleDepth;	// fScale / fScaleDepth

			const int nSamples = 2;
			const float fSamples = 2.0;

			float scale(float fCos)
			{
				float x = 1.0 - fCos;
				return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
			}

			void main(void)
			{
				// Get the ray form the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
				vec3 v3Pos = aVertexPosition.xyz;
				vec3 v3Ray = v3Pos - v3CameraPos;
				float fFar = length(v3Ray);
				v3Ray /= fFar;

				// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)
				float B = 2.0 * dot(v3CameraPos, v3Ray);
				float C = fCameraHeight2 - fOuterRadius2;
				float fDet = max(0.0, B*B - 4.0 * C);
				float fNear = 0.5 * (-B - sqrt(fDet));

				// Calculate the ray's starting position, then calculate its scattering offset
				vec3 v3Start = v3CameraPos + v3Ray * fNear;
				fFar -= fNear;
				float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);
				float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);
				float fLightAngle = dot(v3LightPos, v3Pos) / length(v3Pos);
				float fCameraScale = scale(fCameraAngle);
				float fLightScale = scale(fLightAngle);
				float fCameraOffset = fDepth*fCameraScale;
				float fTemp = (fLightScale + fCameraScale);

				// Initialize the scattering loop variables
				float fSampleLength = fFar / fSamples;
				float fScaledLength = fSampleLength * fScale;
				vec3 v3SampleRay = v3Ray * fSampleLength;
				vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

				// Now loop through the sample rays
				vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
				vec3 v3Attenuate;
				for (int i=0; i<nSamples; i++)
				{
					float fHeight = length(v3SamplePoint);
					float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
					float fScatter = fDepth * fTemp - fCameraOffset;
					v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
					v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
					v3SamplePoint += v3SampleRay;
				}

				primaryColor.rgb = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);

				// Calculate the attenuation factor for the ground
				secondaryColor.rgb = v3Attenuate;

				gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
				//glTexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
				//glTexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;

			}
		</script>

		<script id="GroundFromAtmosphere-fs" type="x-shader/x-fragment">
			precision mediump float;

			varying vec3 primaryColor;
			varying vec3 secondaryColor;

			void main() {
				gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0); return;
				gl_FragColor = vec4(primaryColor + 0.25 * secondaryColor, 1.0);
			}

		</script>

		<script id="GroundFromAtmosphere-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			varying vec2 vTextureCoord;
			varying vec3 primaryColor;
			varying vec3 secondaryColor;

			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;

			uniform vec3 v3CameraPos;
			uniform vec3 v3LightPos;
			uniform vec3 v3InvWavelength;
			uniform float fCameraHeight;
			uniform float fCameraHeight2;
			uniform float fOuterRadius;
			uniform float fOuterRadius2;
			uniform float fInnerRadius;
			uniform float fInnerRadius2;
			uniform float fKrESun;
			uniform float fKmESun;
			uniform float fKr4PI;
			uniform float fKm4PI;
			uniform float fScale;
			uniform float fScaleDepth;
			uniform float fScaleOverScaleDepth;

			const int nSamples = 2;
			const float fSamples = 2.0;

			float scale(float fCos)
			{
				float x = 1.0 - fCos;
				return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
			}

			void main(void) {
				// Get the ray from the camera to the vertex, and its length (which is the far point of the ray passing through the atmosphere)
				vec3 v3Pos = aVertexPosition;
				vec3 v3Ray = v3Pos - v3CameraPos;
				float fFar = length(v3Ray);
				v3Ray /= fFar;

				// Calculate the ray's starting position, then calculate its scattering offset
				vec3 v3Start = v3CameraPos;
				float fDepth = exp((fInnerRadius - fCameraHeight) / fScaleDepth);
				float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);
				float fLightAngle = dot(v3LightPos, v3Pos) / length(v3Pos);
				float fCameraScale = scale(fCameraAngle);
				float fLightScale = scale(fLightAngle);
				float fCameraOffset = fDepth * fCameraScale;
				float fTemp = (fLightScale + fCameraScale);

				// Initialize the scattering loop variables
				float fSampleLength = fFar / fSamples;
				float fScaledLength = fSampleLength * fScale;
				vec3 v3SampleRay = v3Ray * fSampleLength;
				vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

				// Now loop through the sample rays 
				vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
				vec3 v3Attenuate;
				for (int i=0; i < nSamples; i++)
				{
					float fHeight = length(v3SamplePoint);
					float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
					float fScatter = fDepth*fTemp - fCameraOffset;
					v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
					v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
					v3SamplePoint += v3SampleRay;
				}

				primaryColor.rgb = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);

				// Calculate the attenuation factor for the ground
				secondaryColor.rgb = v3Attenuate;

				gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
			}

		</script>	

		<script id="SkyFromSpace-fs" type="x-shader/x-fragment">
			precision mediump float;

			uniform vec3 v3LightPos;
			uniform float g;
			uniform float g2;

			varying vec3 v3Direction;
			varying vec3 frontPrimaryColor;
			varying vec3 frontSecondaryColor;

			varying vec3 debugColor;

			void main(void)
			{
				gl_FragColor = vec4(debugColor, 1.0); return;
				//gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); return;
				float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);
				float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);
				gl_FragColor.xyz = frontPrimaryColor + fMiePhase * frontSecondaryColor;
				gl_FragColor.a = gl_FragColor.b;

				gl_FragColor = vec4(v3Direction, 1.0);
			}
		</script>

		<script id="SkyFromSpace-vs" type="x-shader/x-vertex">
			precision mediump float;

			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			varying vec3 v3Direction;
			varying vec3 frontPrimaryColor;
			varying vec3 frontSecondaryColor;

			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;

			uniform vec3 v3CameraPos;					// The camera's current position
			uniform vec3 v3LightPos;					// The direction vector to the light source
			uniform vec3 v3InvWavelength;				// 1 / pow(wavelength, 4) for the red, green, and blue channels
			uniform float fCameraHeight;				// The camera's current height
			uniform float fCameraHeight2;				// fCameraHeight^2
			uniform float fOuterRadius;					// The outer (atmosphere) radius
			uniform float fOuterRadius2;				// fOuterRadius^2
			uniform float fInnerRadius;					// The inner (planetary) radius
			uniform float fInnerRadius2;				// fInnerRadius^2
			uniform float fKrESun;						// Kr * ESun
			uniform float fKmESun;						// Km * ESun
			uniform float fKr4PI;						// Kr * 4 * PI;
			uniform float fKm4PI;						// Km * 4 * PI 
			uniform float fScale;						// 1 / (fOuterRadius - fInnerRadius)
			uniform float fScaleDepth;					// The scale depth (i.e. the altitude at which the atmosphere's average density is found)
			uniform float fScaleOverScaleDepth;			// fScale / fScaleDepth

			varying vec3 debugColor;

			const int nSamples = 2;
			const float fSamples = 2.0;

			float scale(float fCos)
			{
				float x = 1.0 - fCos;
				return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
			}

			void main(void)
			{
				// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
				vec3 v3Pos = aVertexPosition.xyz;
				vec3 v3Ray = v3Pos - v3CameraPos;
				float fFar = length(v3Ray);
				v3Ray /= fFar;
				
				debugColor = normalize(v3Ray);


				// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)
				float B = 2.0 * dot(v3CameraPos, v3Ray);
				float C = fCameraHeight2 - fOuterRadius2;
				float fDet = max(0.0, B*B - 4.0 * C);
				float fNear = 0.5 * (-B - sqrt(fDet));
				

				// Calculate the ray's starting position, then calculate its scattering offset
				vec3 v3Start = v3CameraPos + v3Ray * fNear;
				fFar -= fNear;
				float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;
				float fStartDepth = exp(-1.0 / fScaleDepth);
				float fStartOffset = fStartDepth * scale(fStartAngle);


				// Initialize the scattering loop variables
				// gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);
				float fSampleLength = fFar / fSamples;			
				float fScaledLength = fSampleLength * fScale;
				vec3 v3SampleRay = v3Ray * fSampleLength;
				vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

				// Now loop through the sample rays
				vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
				for (int i=0; i<nSamples; i++)
				{
					float fHeight = length(v3SamplePoint);
					float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
					float fLightAngle = dot(v3LightPos, v3SamplePoint) / fHeight;
					float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;
					float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));
					vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI * fKm4PI));
					v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
					v3SamplePoint += v3SampleRay;


				}
				debugColor = v3FrontColor;

				// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
				frontSecondaryColor.rgb = v3FrontColor * fKmESun;
				frontPrimaryColor.rgb = v3FrontColor * (v3InvWavelength * fKrESun);
				gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
				v3Direction = v3CameraPos - v3Pos;
			}
		</script>

		<script id="SkyFromAtmosphere-fs" type="x-shader/x-fragment">
			precision mediump float;

			uniform vec3 v3LightPos;
			uniform float g;
			uniform float g2;

			varying vec3 v3Direction;
			varying vec3 frontColor;
			varying vec3 frontSecondaryColor;

			varying vec3 debugColor;

			void main(void)
			{
				//gl_FragColor = vec4(0.98, 0.54, 0.035, 1.0); return;
				float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);
				float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);
				gl_FragColor.xyz = frontColor + fMiePhase * frontSecondaryColor;
				gl_FragColor.a = gl_FragColor.b;
				gl_FragColor = vec4(debugColor, 1.0);
			}


		</script>


		<script id="SkyFromAtmosphere-vs" type="x-shader/x-vertex">
			precision mediump float;

			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			varying vec3 v3Direction;
			varying vec3 frontColor;
			varying vec3 frontSecondaryColor;

			varying vec3 debugColor;

			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;


			uniform vec3 v3CameraPos;				// The camera's current position
			uniform vec3 v3LightPos;				// The direction vector to the light source
			uniform vec3 v3InvWavelength;			// 1 / pow(wavelength, 4) for the red, green, and blue channels
			uniform float fCameraHeight;			// The camera's current height
			uniform float fCameraHeight2;			// fCameraHeight^2
			uniform float fOuterRadius;				// The outer (atmosphere) radius
			uniform float fOuterRadius2;			// fOuterRadius^2
			uniform float fInnerRadius;				// The inner (planetary) radius
			uniform float fInnerRadius2;			// fInnerRadius^2
			uniform float fKrESun;					// Kr * ESun
			uniform float fKmESun;					// Km * Esun
			uniform float fKr4PI;					// Kr * 4 * PI
			uniform float fKm4PI;					// Km * 4 * PI
			uniform float fScale;					// 1 / (fOuterRadius - fInnerRadius)
			uniform float fScaleDepth;				// The scale depth (i.e. the altitude at which the atmosphere's average density is found)
			uniform float fScaleOverScaleDepth;		// fScale / fScaleDepth

			const int nSamples = 2;
			const float fSamples = 2.0;


			float scale(float fCos)
			{
				float x = 1.0 - fCos;
				return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
			}

			void main(void) 
			{
				// Get the ray from the camera to the vertex and its length
				vec3 v3Pos = aVertexPosition.xyz;
				vec3 v3Ray = v3Pos - v3CameraPos;
				float fFar = length(v3Ray);
				v3Ray /= fFar;
		
				// Calculate the ray's starting position, then calculate its scattering offset
				vec3 v3Start = v3CameraPos;
				float fHeight = length(v3Start);
				float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));
				debugColor = vec3(fDepth);
				float fStartAngle = dot(v3Ray, v3Start) / fHeight;
				//debugColor = vec3(fStartAngle);
				float fStartOffset = fDepth * scale(fStartAngle);


				// Initialize the scattering loop variables
				float fSampleLength = fFar / fSamples;
				float fScaledLength = fSampleLength * fScale;			
				vec3 v3SampleRay = v3Ray * fSampleLength;

				vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;
				//vec3 v3SamplePoint = v3Start + v3SampleRay * 1.0;
				debugColor = vec3(0);

				// Now loop through the sample rays
				vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
				// for (int i=0; i<nSamples; i++)
				// {
				// 	float fHeight = length(v3SamplePoint);
				// 	float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
				// 	float fLightAngle = dot(v3LightPos, v3SamplePoint) / fHeight;
				// 	float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;
				// 	float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));
				// 	vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
				// 	v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
				// 	v3SamplePoint += v3SampleRay;

				// 	if (i == 1) {
				// 		//debugColor += v3FrontColor * (v3InvWavelength * fKrESun);
				// 	}
					
					
				// }

				for (int i=0; i<nSamples; i++)
				{
					float fHeight = length(v3SamplePoint);
					float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
					float fLightAngle = dot(v3LightPos, v3SamplePoint) / fHeight;
					float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;
					float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));
					vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
					v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
					v3SamplePoint += v3SampleRay;

					if (i == 0) {
						//debugColor += v3FrontColor * (v3InvWavelength * fKrESun);
						debugColor = v3FrontColor * (v3InvWavelength * fKrESun);
					}
					
					
				}

				// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
				frontSecondaryColor.rgb = v3FrontColor * fKmESun;
				frontColor.rgb = v3FrontColor * (v3InvWavelength * fKrESun);
				debugColor = frontSecondaryColor;

				
				gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
				v3Direction = v3CameraPos - v3Pos;
			}

		</script>





		<script type="text/javascript">
			//  GLOBAL VARS
			var gl;
			var shaderProgram;

			var shaderProgramFramebuffer;

			var planeRenderData;
			var sphereRenderData; 

			var mMatrix = mat4.create();
			var pMatrix = mat4.create();
			var vMatrix = mat4.create();

			//var myCamera;


			var currentlyPressedKeys = {};

			var radiusEarth = 3.0;
			var radiusAtmosphere = 3.5;
			var centerEarth = vec3.fromValues(0.0, 0.0, -5.0);
			var centerAtmosphere = vec3.fromValues(0.0, 0.0, -5.0);

			

			function initGL(canvas) {
				try {
					gl = canvas.getContext("experimental-webgl");
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;
				} catch (e) {					
				}
				if (!gl) {
					alert("Could not initialise WebGL,sorry :-(");
				}
			}

			function getShader(gl, id) {
				var shaderScript = document.getElementById(id);
				if (!shaderScript) {
					return null;
				}

				var str = "";
				var k = shaderScript.firstChild;
				while (k) {
					if (k.nodeType == 3) {
						str += k.textContent;
					}
					k = k.nextSibling;
				}

				var shader;
				if (shaderScript.type == "x-shader/x-fragment") {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} else if (shaderScript.type == "x-shader/x-vertex") {
					shader = gl.createShader(gl.VERTEX_SHADER);
				} else {
					return null;
				}

				gl.shaderSource(shader, str);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert(gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}

			function initShaders() {
				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");

				shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					alert("Could not initialise shaders");
				}
			}

			function initShaderFramebuffer() {
				var fragmentShader = getShader(gl, "shader-fs-framebuffer");
				var vertexShader = getShader(gl, "shader-vs-framebuffer");

				shaderProgramFramebuffer = gl.createProgram();
				gl.attachShader(shaderProgramFramebuffer, vertexShader);
				gl.attachShader(shaderProgramFramebuffer, fragmentShader);
				gl.linkProgram(shaderProgramFramebuffer);

				if (!gl.getProgramParameter(shaderProgramFramebuffer, gl.LINK_STATUS)) {
					alert("Could not initialise shaders");
				}
			}


			function init3DScene() {
				planeRenderData = initBuffersPlane();
				sphereRenderData = generateSphereBuffers();
				cubeRenderData = initBuffersCube();
			}
			

			function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }

		    function drawScene() {
				//

		    	gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferSetupScene);
		    	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

		    	drawShapesAtCameraPosition(vec3.fromValues(4.79, 6.62, 0.16), -42.5, -145.0);


		    	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		    	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

		    	drawShapesWithRay();

		    	gl.viewport(3 * (gl.viewportWidth/4), 2*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
		    	drawScreenFillingTexture(textureFramebufferSetupScene);
		    }


			function tick() {
				requestAnimFrame(tick);

				//renderFrame();
				RenderFrameAtmosphere(0.0);

				//drawScene();
				//drawScene();
				//renderPlane(planeRenderData);
				//renderSphere2(sphereRenderData);
				
				//renderSphere(sphereRenderData, vec3.fromValues(3.0, 0.0, -5.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(0.0, 1.0, 0.0));
				//renderSphere(sphereRenderData, vec3.fromValues(-3.0, 0.0, -5.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(0.0, 1.0, 0.0));
				//renderSphere(sphereRenderData, vec3.fromValues(0.0, 0.0, -8.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(0.0, 1.0, 0.0));
				//renderSphere(sphereRenderData, vec3.fromValues(0.0, 0.0, -2.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(0.0, 1.0, 0.0));

				

				handleKeys();
				//debugCamera();
				updateRay(m_3DCamera.Position, m_3DCamera.Front);
				//debugRay();
				//debugIntersectedPoints();
				calculateDeltaTime();
				animate();

				
			}

			function webGLStart() {
				var canvas = document.getElementById("Atmospheric-scattering-canvas");
				initGL(canvas);
				initShaders();

				initShaderFramebuffer();
				
				//initCamera();
				initGameEngine();

				updateRay(m_3DCamera.Position, m_3DCamera.Front);

				init3DScene();

				createFramebuffer();

				gl.clearColor(0.0, 1.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);

				document.onkeydown = handleKeyDown;
				document.onkeyup = handleKeyUp;
				document.onmousemove = handleMouseMove;

				tick();
			}
		</script>

	</head>

	<body onload="webGLStart();">
		<canvas id="Atmospheric-scattering-canvas" style="border: none;" width="1024" height="1024"></canvas>
	</body>

</html>